using System; using System.Collections; using UnityEngine; using UnityEngine.Networking;  namespace MainApp.Cache
{     /// <summary>     /// Second chain of validation     /// </summary>     public class ETagValidator : CacheValidationHandler     {         public override IEnumerator Handle(RemoteTextureInfo textureInfo, FileCache cache)         {             Debug.Log($"[ETagValidator] Check ETag for {textureInfo.name}");              using (UnityWebRequest request = UnityWebRequest.Head(textureInfo.url))             {                 yield return request.SendWebRequest();                  if (request.result == UnityWebRequest.Result.Success)                 {                     string etag = request.GetResponseHeader("ETag");                      if (!string.IsNullOrEmpty(etag))                     {                         string cleanETag = CleanETag(etag);                         textureInfo.checksum = cleanETag;                          // get meta-data                         textureInfo.fileSize = GetFileSize(request);                         textureInfo.lastModified = GetLastModified(request);                          if (cache.IsFileValid(textureInfo.url, cleanETag))                         {                             Debug.Log($"[{nameof(ETagValidator)}] File {textureInfo.name} current according by ETag");                             textureInfo.downloadStatus = RemoteTextureInfo.DownloadStatus.CachedValid;                         }                         else                         {                             Debug.Log($"[{nameof(ETagValidator)}] File {textureInfo.name} outdated according by ETag");                             textureInfo.downloadStatus = RemoteTextureInfo.DownloadStatus.NeedDownload;                             cache.UpdateCacheEntry(textureInfo.url, cleanETag);                         }                         yield break;                     }                 }                  Debug.Log($"[{nameof(ETagValidator)}] ETag not allowed for {textureInfo.name}, next chain validation");                 yield return HandleNext(textureInfo, cache);             }         }          private string CleanETag(string etag)         {             return etag.Trim('"', '\'').Replace("W/", "");         }          private long GetFileSize(UnityWebRequest request)         {             string sizeHeader = request.GetResponseHeader("Content-Length");             return long.TryParse(sizeHeader, out long size) ? size : 0;         }          private DateTime GetLastModified(UnityWebRequest request)         {             string dateHeader = request.GetResponseHeader("Last-Modified");             return DateTime.TryParse(dateHeader, out DateTime date) ? date : DateTime.MinValue;         }     } } 