using System; using System.Collections; using System.Text; using UnityEngine; using UnityEngine.Networking;  namespace MainApp.Cache
{     /// <summary>     /// LMCL - Last-Modified & Content Length. This is a fallback implementation of checksum verification in case one of the primary checksums is unavailable or an error occurs.     /// </summary>     public class LMCLValidator : CacheValidationHandler     {         public override IEnumerator Handle(RemoteTextureInfo textureInfo, FileCache cache)         {             Debug.Log($"[{nameof(LMCLValidator)}] Check LMCL for {textureInfo.name}");              using (UnityWebRequest request = UnityWebRequest.Head(textureInfo.url))             {                 yield return request.SendWebRequest();                  if (request.result == UnityWebRequest.Result.Success)                 {                     // Получаем метаданные                     string lastModified = request.GetResponseHeader("Last-Modified");                     string contentLength = request.GetResponseHeader("Content-Length");                      textureInfo.fileSize = long.TryParse(contentLength, out long size) ? size : 0;                     textureInfo.lastModified = DateTime.TryParse(lastModified, out DateTime date) ? date : DateTime.MinValue;                      // Генерируем checksum из LMCL                     string lmclChecksum = GenerateLMCLChecksum(lastModified, contentLength);                     textureInfo.checksum = lmclChecksum;                      // Сравниваем с кэшем                     if (cache.IsFileValid(textureInfo.url, lmclChecksum))                     {                         Debug.Log($"[{nameof(LMCLValidator)}] File {textureInfo.name} current according by LMCL");                         textureInfo.downloadStatus = RemoteTextureInfo.DownloadStatus.CachedValid;                     }                     else                     {                         Debug.Log($"[{nameof(LMCLValidator)}] File {textureInfo.name} outdated according by LMCL");                         textureInfo.downloadStatus = RemoteTextureInfo.DownloadStatus.NeedDownload;                         cache.UpdateCacheEntry(textureInfo.url, lmclChecksum);                     }                 }                 else                 {                     Debug.LogWarning($"[{nameof(LMCLValidator)}] Failed to check {textureInfo.name}: {request.error}");                     textureInfo.downloadStatus = RemoteTextureInfo.DownloadStatus.DownloadError;                 }             }         }          private string GenerateLMCLChecksum(string lastModified, string contentLength)         {             StringBuilder sb = new StringBuilder();              if (!string.IsNullOrEmpty(lastModified))             {                 if (DateTime.TryParse(lastModified, out DateTime date))                 {                     sb.Append(date.ToString("yyyyMMddHHmm"));                 }             }              if (!string.IsNullOrEmpty(contentLength))             {                 sb.Append("_");                 sb.Append(contentLength);             }              string combined = sb.ToString();             return string.IsNullOrEmpty(combined) ? "unknown" : combined.GetHashCode().ToString("X");         }     } }