using System; using System.Collections; using System.Collections.Generic; using System.IO; using System.Text; using UnityEngine; using UnityEngine.Networking;  public class ServerService : MonoBehaviour {     private const string SERVER_URL = "http://data.ikppbb.com"; // TODO: replace to config     private const string picsFolderUrl = "/test-task-unity-data/pics/"; // TODO: replace to config      private List<RemoteTextureInfo> remoteTextureInfos = new List<RemoteTextureInfo>();     private FileCache fileCache;     private CacheValidationHandler validationChain;      private bool enableCaching = true; // TODO: replace to config     private bool clearCacheOnStart = false; // TODO: replace to config     private float delayBetweenRequests = 0.5f; // TODO: replace to config      void Start()     {         InitializeCache();         InitializeValidationChain();         StartCoroutine(ProcessServerFiles());     }      private void InitializeCache()     {         fileCache = new FileCache();          if (clearCacheOnStart)         {             fileCache.ClearCache();             Debug.Log("Cache cleared");         }          long cacheSize = fileCache.GetCacheSize();         Debug.Log($"Cache size: {FormatBytes(cacheSize)}");     }      private void InitializeValidationChain()     {         var localChecker = new LocalCacheChecker();         var etagChecker = new ETagValidator();         var lmclChecker = new LMCLValidator();          localChecker.SetNext(etagChecker).SetNext(lmclChecker);         validationChain = localChecker;     }      IEnumerator ProcessServerFiles()     {         Debug.Log("Start server files process...");          List<string> fileUrls = new List<string>();         yield return StartCoroutine(GetFileListFromServer(fileUrls));          Debug.Log($"Content files found: {fileUrls.Count}");          foreach (string fileUrl in fileUrls)         {             RemoteTextureInfo textureInfo = CreateTextureInfo(fileUrl);             remoteTextureInfos.Add(textureInfo);              yield return StartCoroutine(validationChain.Handle(textureInfo, fileCache));              switch (textureInfo.downloadStatus)             {                 case RemoteTextureInfo.DownloadStatus.CachedValid:                     Debug.Log($"{textureInfo.name} - already contains in cache, using local");                     break;                  case RemoteTextureInfo.DownloadStatus.NeedDownload:                     Debug.Log($"{textureInfo.name} - need download");                     yield return StartCoroutine(DownloadFile(textureInfo));                     break;                  case RemoteTextureInfo.DownloadStatus.DownloadError:                     Debug.LogWarning($"{textureInfo.name} - validation error");                     break;             }              yield return new WaitForSeconds(delayBetweenRequests);         }          PrintResults();     }      IEnumerator GetFileListFromServer(List<string> fileUrls)     {         string fullUrl = SERVER_URL + picsFolderUrl;          using (UnityWebRequest request = UnityWebRequest.Get(fullUrl))         {             yield return request.SendWebRequest();              if (request.result == UnityWebRequest.Result.Success)             {                 string html = request.downloadHandler.text;                 var matches = System.Text.RegularExpressions.Regex.Matches(                     html,                     @"<a href=""([^""]+\.(png|jpg|svg))""",                     System.Text.RegularExpressions.RegexOptions.IgnoreCase                 );                  foreach (System.Text.RegularExpressions.Match match in matches)                 {                     if (match.Groups.Count >= 2)                     {                         string relativeUrl = match.Groups[1].Value;                         string absoluteUrl = SERVER_URL + picsFolderUrl + relativeUrl;                         fileUrls.Add(absoluteUrl);                     }                 }             }         }          yield break;     }      private RemoteTextureInfo CreateTextureInfo(string url)     {         return new RemoteTextureInfo         {             name = Path.GetFileNameWithoutExtension(url),             url = url,             extension = Path.GetExtension(url).ToLower(),             downloadStatus = RemoteTextureInfo.DownloadStatus.NotChecked         };     }      IEnumerator DownloadFile(RemoteTextureInfo textureInfo)     {         Debug.Log($"Downloading {textureInfo.name}...");          using (UnityWebRequest request = UnityWebRequest.Get(textureInfo.url))         {             yield return request.SendWebRequest();              if (request.result == UnityWebRequest.Result.Success)             {                 byte[] data = request.downloadHandler.data;                  // Сохраняем в кэш                 if (enableCaching)                 {                     fileCache.SaveFileToCache(textureInfo.url, data);                     Debug.Log($"File {textureInfo.name} saved to cache ({FormatBytes(data.Length)})");                 }                  // Texture2D texture = new Texture2D(2, 2);                 // texture.LoadImage(data);             }             else             {                 Debug.LogError($"Downloading error {textureInfo.name}: {request.error}");             }         }     }      private void PrintResults()     {         StringBuilder sb = new StringBuilder();         sb.AppendLine("=== PROCESSING RESULT ===");          int cached = 0;         int toDownload = 0;         int errors = 0;          foreach (var info in remoteTextureInfos)         {             switch (info.downloadStatus)             {                 case RemoteTextureInfo.DownloadStatus.CachedValid: cached++; break;                 case RemoteTextureInfo.DownloadStatus.NeedDownload: toDownload++; break;                 case RemoteTextureInfo.DownloadStatus.DownloadError: errors++; break;             }         }          sb.AppendLine($"Files count: {remoteTextureInfos.Count}");         sb.AppendLine($"Cached (current accorded): {cached}");         sb.AppendLine($"Need download: {toDownload}");         sb.AppendLine($"Errors: {errors}");          long cacheSize = fileCache.GetCacheSize();         sb.AppendLine($"Summary cache size: {FormatBytes(cacheSize)}");         Debug.Log(sb);     }      private string FormatBytes(long bytes)     {         string[] suffixes = { "B", "KB", "MB", "GB" };         int counter = 0;         decimal number = bytes;          while (Math.Round(number / 1024) >= 1)         {             number /= 1024;             counter++;         }          return $"{number:n1} {suffixes[counter]}";     }      public void ClearCacheButton()     {         fileCache.ClearCache();         Debug.Log("Cache cleaned manualy");     }      public void RecheckFilesButton()     {         StopAllCoroutines();         remoteTextureInfos.Clear();         StartCoroutine(ProcessServerFiles());     } }